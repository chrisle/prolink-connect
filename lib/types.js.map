{"version":3,"file":"types.js","mappings":";;;;;;;;;;;;;AAEA;;GAEG;AACH,IAAY,UAKX;AALD,WAAY,UAAU;IACpB,6CAAc;IACd,4CAAa;IACb,gDAAe;IACf,kDAAgB;AAClB,CAAC,EALW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAKrB;AAED;;GAEG;AACH,IAAY,SAYX;AAZD,WAAY,SAAS;IACnB,2CAAY;IACZ,+CAAc;IACd,+CAAc;IACd,+CAAc;IACd,6CAAa;IACb,yCAAW;IACX,2CAAY;IACZ,uDAAkB;IAClB,mDAAgB;IAChB,kDAAe;IACf,4CAAY;AACd,CAAC,EAZW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAYpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBD,uGAA8C;AAsB9C;;GAEG;AACH,IAAY,UAIX;AAJD,WAAY,UAAU;IACpB,yCAAU;IACV,6CAAY;IACZ,qDAAgB;AAClB,CAAC,EAJW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAIrB;AAsED,IAAY,UAUX;AAVD,WAAY,UAAU;IACpB,iDAAc;IACd,2CAAW;IACX,yCAAU;IACV,+CAAa;IACb,+CAAa;IACb,6CAAY;IACZ,2CAAW;IACX,2CAAW;IACX,+CAAa;AACf,CAAC,EAVW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAUrB;AAED;;GAEG;AACH,IAAY,SAMX;AAND,WAAY,SAAS;IACnB,2CAAY;IACZ,qCAAS;IACT,qCAAS;IACT,uCAAU;IACV,qCAAS;AACX,CAAC,EANW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAMpB;AAED;;GAEG;AACH,IAAY,SAKX;AALD,WAAY,SAAS;IACnB,yCAAW;IACX,qCAAS;IACT,qDAAiB;IACjB,+CAAc;AAChB,CAAC,EALW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAKpB;AAgFD;;GAEG;AACH,IAAY,YASX;AATD,WAAY,YAAY;IACtB,yCAAK;IACL,yCAAC;IACD,yCAAC;IACD,yCAAC;IACD,yCAAC;IACD,yCAAC;IACD,yCAAC;IACD,yCAAC;AACH,CAAC,EATW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QASvB;AAED;;;GAGG;AACH,IAAY,QAmBX;AAnBD,WAAY,QAAQ;IAClB,uCAAW;IACX,0CAAY;IACZ,8CAAc;IACd,4CAAa;IACb,8CAAc;IACd,4DAAqB;IACrB,uCAAW;IACX,iDAAgB;IAChB,uCAAW;IACX,gDAAe;IACf,wCAAW;IACX,0CAAY;IACZ,wCAAW;IACX,0CAAY;IACZ,4CAAa;IACb,4CAAa;IACb,sCAAU;IACV,wCAAW;AACb,CAAC,EAnBW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAmBnB;AA4ED,IAAY,YAoBX;AApBD,WAAY,YAAY;IACtB;;;OAGG;IACH,qDAAO;IACP;;;OAGG;IACH,mDAAM;IACN;;OAEG;IACH,yDAAS;IACT;;;OAGG;IACH,mDAAM;AACR,CAAC,EApBW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAoBvB;AAED;;;GAGG;AACH,IAAY,aA+BX;AA/BD,WAAY,aAAa;IACvB;;;;;;;;;;;;;;;;;;OAkBG;IACH,+DAAW;IACX;;;;OAIG;IACH,uEAAe;IACf;;OAEG;IACH,mEAAa;AACf,CAAC,EA/BW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QA+BxB;;;;;;;UChYD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://prolink-connect/./src/status/types.ts","webpack://prolink-connect/./src/types.ts","webpack://prolink-connect/webpack/bootstrap","webpack://prolink-connect/webpack/before-startup","webpack://prolink-connect/webpack/startup","webpack://prolink-connect/webpack/after-startup"],"sourcesContent":["import {DeviceID, MediaSlot, TrackType} from 'src/types';\n\n/**\n * Status flag bitmasks\n */\nexport enum StatusFlag {\n  OnAir = 1 << 3,\n  Sync = 1 << 4,\n  Master = 1 << 5,\n  Playing = 1 << 6,\n}\n\n/**\n * Play state flags\n */\nexport enum PlayState {\n  Empty = 0x00,\n  Loading = 0x02,\n  Playing = 0x03,\n  Looping = 0x04,\n  Paused = 0x05,\n  Cued = 0x06,\n  Cuing = 0x07,\n  PlatterHeld = 0x08,\n  Searching = 0x09,\n  SpunDown = 0x0e,\n  Ended = 0x11,\n}\n\n/**\n * Represents various details about the current state of the CDJ.\n */\nexport interface State {\n  /**\n   * The device reporting this status.\n   */\n  deviceId: number;\n  /**\n   * The ID of the track loaded on the device.\n   *\n   * 0 When no track is loaded.\n   */\n  trackId: number;\n  /**\n   * The device ID the track is loaded from.\n   *\n   * For example if you have two CDJs and you've loaded a track over the 'LINK',\n   * this will be the ID of the player with the USB media device connected to it.\n   */\n  trackDeviceId: DeviceID;\n  /**\n   * The MediaSlot the track is loaded from. For example a SD card or USB device.\n   */\n  trackSlot: MediaSlot;\n  /**\n   * The TrackType of the track, for example a CD or Rekordbox analyzed track.\n   */\n  trackType: TrackType;\n  /**\n   * The current play state of the CDJ.\n   */\n  playState: PlayState;\n  /**\n   * Whether the CDJ is currently reporting itself as 'on-air'.\n   *\n   * This is indicated by the red ring around the platter on the CDJ Nexus models.\n   * A DJM mixer must be ont he network for the CDJ to report this as true.\n   */\n  isOnAir: boolean;\n  /**\n   * Whether the CDJ is synced.\n   */\n  isSync: boolean;\n  /**\n   * Whether the CDJ is the master player.\n   */\n  isMaster: boolean;\n  /**\n   * Whether the CDJ is in an emergency state (emergecy loop / emergency mode\n   * on newer players)\n   */\n  isEmergencyMode: boolean;\n  /**\n   * The BPM of the loaded track. null if no track is loaded or the BPM is unknown.\n   */\n  trackBPM: number | null;\n  /**\n   * The \"effective\" pitch of the plyaer. This is reported anytime the jogwheel is\n   * nudged, the CDJ spins down by pausing with the vinyl stop knob not at 0, or\n   * by holding the platter.\n   */\n  effectivePitch: number;\n  /**\n   * The current slider pitch\n   */\n  sliderPitch: number;\n  /**\n   * The current beat within the measure. 1-4. 0 when no track is loaded.\n   */\n  beatInMeasure: number;\n  /**\n   * Number of beats remaining until the next cue point is reached. Null if there\n   * is no next cue point\n   */\n  beatsUntilCue: number | null;\n  /**\n   * The beat 'timestamp' of the track. Can be used to compute absolute track time\n   * given the slider pitch.\n   */\n  beat: number | null;\n  /**\n   * A counter that increments for every status packet sent.\n   */\n  packetNum: number;\n}\n","import type {Address4} from 'ip-address';\n\nimport type {Playlist, Track} from './entities';\n\nexport * as CDJStatus from 'src/status/types';\n\n/**\n * Re-export various types for the types only compile target\n */\n\nexport type {\n  Album,\n  Artist,\n  Artwork,\n  Color,\n  Genre,\n  Key,\n  Label,\n  Playlist,\n  Track,\n} from './entities';\nexport type {HydrationProgress} from './localdb/rekordbox';\nexport type {MixstatusConfig, MixstatusProcessor} from './mixstatus';\nexport type {ConnectedProlinkNetwork, NetworkConfig, ProlinkNetwork} from './network';\nexport type {FetchProgress} from './nfs';\n\n/**\n * Known device types on the network\n */\nexport enum DeviceType {\n  CDJ = 0x01,\n  Mixer = 0x03,\n  Rekordbox = 0x04,\n}\n\n/**\n * The 8-bit identifier of the device on the network\n */\nexport type DeviceID = number;\n\n/**\n * Represents a device on the prolink network.\n */\nexport interface Device {\n  name: string;\n  id: DeviceID;\n  type: DeviceType;\n  macAddr: Uint8Array;\n  ip: Address4;\n  lastActive?: Date;\n}\n\n/**\n * Details of a particular media slot on the CDJ\n */\nexport interface MediaSlotInfo {\n  /**\n   * The device the slot physically exists on\n   */\n  deviceId: DeviceID;\n  /**\n   * The slot type\n   */\n  slot: MediaSlot;\n  /**\n   * The name of the media connected\n   */\n  name: string;\n  /**\n   * The rekordbox configured color of the media connected\n   */\n  color: MediaColor;\n  /**\n   * Creation date\n   */\n  createdDate: Date;\n  /**\n   * Number of free bytes available on the media\n   */\n  freeBytes: bigint;\n  /**\n   * Number of bytes used on the media\n   */\n  totalBytes: bigint;\n  /**\n   * Specifies the available tracks type on the media\n   */\n  tracksType: TrackType;\n  /**\n   * Total number of rekordbox tracks on the media. Will be zero if there is\n   * no rekordbox database on the media\n   */\n  trackCount: number;\n  /**\n   * Same as track count, except for playlists\n   */\n  playlistCount: number;\n  /**\n   * True when a rekordbox 'my settings' file has been exported to the media\n   */\n  hasSettings: boolean;\n}\n\nexport enum MediaColor {\n  Default = 0x00,\n  Pink = 0x01,\n  Red = 0x02,\n  Orange = 0x03,\n  Yellow = 0x04,\n  Green = 0x05,\n  Aqua = 0x06,\n  Blue = 0x07,\n  Purple = 0x08,\n}\n\n/**\n * A slot where media is present on the CDJ\n */\nexport enum MediaSlot {\n  Empty = 0x00,\n  CD = 0x01,\n  SD = 0x02,\n  USB = 0x03,\n  RB = 0x04,\n}\n\n/**\n * Track type flags\n */\nexport enum TrackType {\n  None = 0x00,\n  RB = 0x01,\n  Unanalyzed = 0x02,\n  AudioCD = 0x05,\n}\n\n/**\n * A beat grid is a series of offsets from the start of the track. Each offset\n * indicates what count within the measure it is along with the BPM.\n */\nexport type BeatGrid = Array<{\n  /**\n   * Offset from the beginning of track in milliseconds of this beat.\n   */\n  offset: number;\n  /**\n   * The count of this particular beat within the measure\n   */\n  count: 1 | 2 | 3 | 4;\n  /**\n   * The BPM at this beat.\n   */\n  bpm: number;\n}>;\n\n/**\n * A waveform segment contains a height and 'whiteness' value.\n */\ninterface WaveformSegment {\n  /**\n   * The height this segment in the waveform. Ranges from 0 - 31.\n   */\n  height: number;\n  /**\n   * The level of \"whiteness\" of the waveform. 0 being completely blue, and 1\n   * being completely white.\n   */\n  whiteness: number;\n}\n\n/**\n * A HD waveform segment contains the height of the waveform, and it's color\n * represented as RGB values.\n */\ninterface WaveformHDSegment {\n  /**\n   * The height this segment in the waveform. Ranges from 0 - 31.\n   */\n  height: number;\n  /**\n   * the RGB value, each channel ranges from 0-1 for the segment.\n   */\n  color: [number, number, number];\n}\n\n/**\n * The waveform preview will be 400 segments of data.\n */\nexport type WaveformPreview = WaveformSegment[];\n\n/**\n * Detailed waveforms have 150 segments per second of audio (150 'half frames'\n * per second of audio).\n */\nexport type WaveformDetailed = WaveformSegment[];\n\n/**\n * HD waveforms have 150 segments per second of audio (150 'half frames' per\n * second of audio).\n */\nexport type WaveformHD = WaveformHDSegment[];\n\n/**\n * The result of looking up track waveforms\n */\nexport interface Waveforms {\n  /**\n   * The full-size and full-color waveform\n   */\n  waveformHd: WaveformHD;\n\n  // TODO: Add other waveform types\n}\n\n/**\n * A hotcue button label\n */\nexport enum HotcueButton {\n  A = 1,\n  B,\n  C,\n  D,\n  E,\n  F,\n  G,\n  H,\n}\n\n/**\n * When a custom color is not configured the cue point will be one of these\n * colors.\n */\nexport enum CueColor {\n  None = 0x00,\n  Blank = 0x15,\n  Magenta = 0x31,\n  Violet = 0x38,\n  Fuchsia = 0x3c,\n  LightSlateBlue = 0x3e,\n  Blue = 0x01,\n  SteelBlue = 0x05,\n  Aqua = 0x09,\n  SeaGreen = 0x0e,\n  Teal = 0x12,\n  Green = 0x16,\n  Lime = 0x1a,\n  Olive = 0x1e,\n  Yellow = 0x20,\n  Orange = 0x26,\n  Red = 0x2a,\n  Pink = 0x2d,\n}\n\n/**\n * Represents a single cue point. On older exports the label and color may be\n * undefined.\n */\nexport interface CuePoint {\n  type: 'cue_point';\n  /**\n   * Number of milliseconds from the start of the track.\n   */\n  offset: number;\n  /**\n   * The comment associated to the cue point\n   */\n  label?: string;\n  /**\n   * RGB values of the hotcue color\n   */\n  color?: CueColor;\n}\n\ntype BareCuePoint = Omit<CuePoint, 'type'>;\n\n/**\n * A loop, similar to a cue point, but includes a length.\n */\nexport type Loop = BareCuePoint & {\n  type: 'loop';\n  /**\n   * The length in milliseconds of the loop\n   */\n  length: number;\n};\n\n/**\n * A hotcue is like a cue point, but also includes the button it is assigned to.\n */\nexport type Hotcue = BareCuePoint & {\n  type: 'hot_cue';\n  /**\n   * Which hotcue button this hotcue is assigned to.\n   */\n  button: HotcueButton;\n};\n\n/**\n * A hot loop, this is the union of a hotcue and a loop.\n */\nexport type Hotloop = {type: 'hot_loop'} & (Omit<Hotcue, 'type'> & Omit<Loop, 'type'>);\n\nexport type CueAndLoop = CuePoint | Loop | Hotcue | Hotloop;\n\n/**\n * Represents the contents of a playlist\n */\nexport interface PlaylistContents {\n  /**\n   * The playlists in this playlist.\n   */\n  playlists: Playlist[];\n  /**\n   * The folders in this playlist.\n   */\n  folders: Playlist[];\n  /**\n   * The tracks in this playlist. This is an AsyncIterator as looking up track\n   * metadata may be slow when connected to the remote database.\n   */\n  tracks: AsyncIterable<Track>;\n  /**\n   * The total number of tracks in this playlist.\n   */\n  totalTracks: number;\n}\n\nexport enum NetworkState {\n  /**\n   * The network is offline when we don't have an open connection to the network\n   * (no connection to the announcment and or status UDP socket is present).\n   */\n  Offline,\n  /**\n   * The network is online when we have opened sockets to the network, but have\n   * not yet started announcing ourselves as a virtual CDJ.\n   */\n  Online,\n  /**\n   * The network is connected once we have heard from another device on the network\n   */\n  Connected,\n  /**\n   * The network may have failed to connect if we aren't able to open the\n   * announcment and or status UDP socket.\n   */\n  Failed,\n}\n\n/**\n * Mixstatus reporting modes specify how the mixstatus processor will determine when a new\n * track is 'now playing'.\n */\nexport enum MixstatusMode {\n  /**\n   * Tracks will be smartly marked as playing following rules:\n   *\n   * - The track that has been in the play state with the CDJ in the \"on air\" state\n   *   for the longest period of time (allowing for a configurable length of\n   *   interruption with allowedInterruptBeats) is considered to be the active\n   *   track that incoming tracks will be compared against.\n   *\n   * - A incoming track will immediately be reported as nowPlaying if it is on\n   *   air, playing, and the last active track has been cued.\n   *\n   * - A incoming track will be reported as nowPlaying if the active track has\n   *   not been on air or has not been playing for the configured\n   *   allowedInterruptBeats.\n   *\n   * - A incoming track will be reported as nowPlaying if it has played\n   *   consecutively (with allowedInterruptBeats honored for the incoming track)\n   *   for the configured beatsUntilReported.\n   */\n  SmartTiming,\n  /**\n   * Tracks will not be reported after the beatsUntilReported AND will ONLY\n   * be reported if the other track has gone into a non-playing play state, or\n   * taken off air (when useOnAirStatus is enabled).\n   */\n  WaitsForSilence,\n  /**\n   * The track will simply be reported only after the player becomes master.\n   */\n  FollowsMaster,\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/types.ts\");\n",""],"names":[],"sourceRoot":""}